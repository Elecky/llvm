#include "NNPUTargetMachine.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===--------------------------------------------------------------------===//
/// NNPUDAGToDAGISel - NNPU specific code to select NNPU machine
/// instructions for SelectionDAG operations.
///
namespace llvm {

class NNPUDAGToDAGISel : public SelectionDAGISel {
    /// Subtarget - Keep a pointer to the NNPU Subtarget around so that we can
    /// make the right decision when generating code for different targets.
    const NNPUSubtarget *Subtarget;

public:
    explicit NNPUDAGToDAGISel(NNPUTargetMachine &tm) : SelectionDAGISel(tm) {}

    bool runOnMachineFunction(MachineFunction &MF) override {
        Subtarget = &MF.getSubtarget<NNPUSubtarget>();
        return SelectionDAGISel::runOnMachineFunction(MF);
    }

    void Select(SDNode *N) override;

    // Complex Pattern Selectors.
    bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);

    /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
    /// inline asm expressions.
    // bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
    //                                     std::vector<SDValue> &OutOps) override;

    StringRef getPassName() const override {
        return "NNPU DAG->DAG Pattern Instruction Selection";
    }

    // Include the pieces autogenerated from the target description.
#include "NNPUGenDAGISel.inc"

private:
    // SDNode *getGlobalBaseReg();
    inline SDValue getImm(const SDNode *Node, unsigned Imm)
    {
        return CurDAG->getTargetConstant(Imm, SDLoc(Node), Node->getValueType(0));
    }

    bool trySelect(SDNode *N);
};

bool NNPUDAGToDAGISel::SelectADDRri(SDValue Addr, SDValue &Base, SDValue &Offset)
{
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
        Base = CurDAG->getTargetFrameIndex(
            FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
        Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
        return true;
    }
    if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
        Addr.getOpcode() == ISD::TargetGlobalAddress ||
        Addr.getOpcode() == ISD::TargetGlobalTLSAddress)
    {
        llvm_unreachable("not intended SelectADDRri branch");
        return false;  // direct calls.
    }

    if (Addr.getOpcode() == ISD::ADD) {
        if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
            if (FrameIndexSDNode *FIN =
                    dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
                // Constant offset from frame ref.
                Base = CurDAG->getTargetFrameIndex(
                    FIN->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
            } else {
                Base = Addr.getOperand(0);
            }
            Offset = CurDAG->getTargetConstant(CN->getSExtValue(), SDLoc(Addr),
                                            MVT::i32);
            return true;
        }
        if (dyn_cast<GlobalAddressSDNode>(Addr.getOperand(1))) {
            Base = Addr.getOperand(0);
            Offset = Addr.getOperand(1);
            return true;
        }

        llvm_unreachable("unexpected condition");
    }
    Base = Addr;
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
    return true;
}

void NNPUDAGToDAGISel::Select(SDNode *Node)
{
    unsigned opCode = Node->getOpcode();

    // #define DEBUG_TYPE isel

    // LLVM_DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

    if (Node->isMachineOpcode())
    {
        // LLVM_DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
        Node->setNodeId(-1);
        return;
    }

    if (trySelect(Node))
    {
        return;
    }

    SelectCode(Node);
}

bool NNPUDAGToDAGISel::trySelect(SDNode *Node)
{
    unsigned opCode = Node->getOpcode();
    SDLoc DL(Node);

    // EVT NodeTy = Node->getValueType(0);

    switch (opCode)
    {
    default:
        break;
    }

    return false;
}

} // end namespace llvm

/// createNNPUcISelDag - This pass converts a legalized DAG into a
/// NNPUC-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createNNPUISelDag(NNPUTargetMachine &TM) {
    return new NNPUDAGToDAGISel(TM);
}